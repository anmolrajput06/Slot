const Player = require("../models/player");
const SlotGame = require("../models/game");
const { checkPaylineWin } = require("../helper/calculateWin");
const paylines = require("../helper/paylines");

const spin = async (req, res) => {
  const { playerId, betAmount } = req.body;
  const MAX_WIN_LIMIT = 250000;
  const RTP_PERCENTAGE = 100;

  try {
    const player = await Player.findById(playerId);
    if (!player) return res.status(404).json({ msg: "Player not found" });

    if (player.coins < betAmount) {
      return res.status(400).json({ msg: "Not enough coins" });
    }

    const symbols = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14"];
    let reels = Array.from({ length: 5 }, () =>
      Array.from({ length: 4 }, () => symbols[Math.floor(Math.random() * symbols.length)])
    );

    if (!isValidReelState(reels)) {
      return res.status(500).json({ msg: "Malfunction detected. Spin voided." });
    }

    // Check for PERSISTING WILD replacement
    reels = replacePersistingWild(reels);

    const { totalWin, winningLines } = checkPaylineWin(reels, betAmount);
    let finalWin = Math.min(totalWin, MAX_WIN_LIMIT);
    let adjustedWin = (finalWin * (RTP_PERCENTAGE / 100)).toFixed(2);

    const featureCount = countFeatureSymbols(reels);
    
    const freeSpinsWon = featureCount >= 5 ? Math.min(5 + (featureCount - 5) * 5, 80) : 0;
    const persistingWilds = convertGoldFeatureToPersistingWild(reels);

    player.coins = player.coins - betAmount + parseFloat(adjustedWin);
    player.freeSpins += freeSpinsWon;
    await player.save();

    const gameData = new SlotGame({
      playerId,
      reels,
      freeSpins: freeSpinsWon,
      totalWin: parseFloat(adjustedWin),
      winningLines,
      persistingWilds,
      status: "Completed",
    });

    res.json({
      msg: "Spin complete",
      reels,
      totalWin,
      winningLines,
      freeSpinsWon,
      persistingWilds,
    });
  } catch (err) {
    console.error("Malfunction detected:", err);
    res.status(500).json({ msg: "Malfunction voids all pays and plays." });
  }
};

const replacePersistingWild = (reels) => {
  return reels.map((reel) =>
    reel.map((symbol) => (symbol === "12" || symbol == "13") ? "11" : symbol)
  );
};

const countFeatureSymbols = (reels) => {
  return reels.flat().filter(symbol => symbol == "11" || symbol == "12").length;
};

const convertGoldFeatureToPersistingWild = (reels) => {
  return reels.map((reel) =>
    reel.map((symbol) => (symbol == "12" ? "PERSISTING_WILD" : symbol))
  );
};

const freeSpin = async (req, res) => {
  const { playerId } = req.body;

  try {
    let player = await Player.findById(playerId);
    if (!player || player.freeSpins <= 0) return res.status(400).json({ msg: "No free spins available" });

    player.freeSpins -= 1;
    await player.save();

    return res.json({ msg: "Free spin used", remainingFreeSpins: player.freeSpins });
  } catch (err) {
    return res.status(500).json({ msg: "Server error" });
  }
};
const isValidReelState = (reels) => {
  const validSymbols = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14"];
  return reels.flat().every(symbol => validSymbols.includes(symbol));
};

module.exports = { spin, freeSpin };


const paytable = {
  0: 0.25,  //scatter
  1: 5.0, //"golden_rooster"
  2: 1.0,//"purple_rooster"
  3: 0.50, //"red_rooster"
  4: 0.20, //"white_rooster"
  5: 0.07,// "dark_blue_rooster"
  6: 0.05, // "blue_rooster"
  7: 0.03  //"green_rooster"
};
const paylines = [
  [1, 1, 1],
  [0, 0, 0],
  [2, 2, 2],
  [0, 1, 2],
  [2, 0, 0],
];



function playBonusGame() {
  let totalPrize = 0;
  let fightResults = [];
  let round = 1;
  let wins = [6, 8, 10, 15, 20, 30];

  while (round <= 6) {
      const playerPoints = Math.floor(Math.random() * 5) + 1;
      const opponentPoints = Math.floor(Math.random() * 5) + 1;
      fightResults.push({ round, playerPoints, opponentPoints });
      if (playerPoints > opponentPoints) {
          totalPrize += wins[round - 1];
          round++;
      } else break;
  }
  return { fightResults, totalPrize };
}

function playRiskGame(wager) {
  const dealerCard = Math.floor(Math.random() * 13) + 2;
  const playerCard = Math.floor(Math.random() * 13) + 2;
  let result = "draw";

  if (playerCard > dealerCard) result = "win";
  else if (playerCard < dealerCard) result = "lose";

  return { dealerCard, playerCard, result };
}



const checkPaylineWin = (reels, betAmount) => {
  let totalWin = 0;
  let winningLines = [];
  let isFight = false
  const payoutTable = {
      0: 0.25,  // scatter
      1: 5.0,    // "golden_rooster"
      2: 1.0,    // "purple_rooster"
      3: 0.50,   // "red_rooster"
      4: 0.20,   // "white_rooster"
      5: 0.07,   // "dark_blue_rooster"
      6: 0.05,   // "blue_rooster"
      7: 0.03    // "green_rooster"
  };

  const paylines = [
      [1, 1, 1], // Payline 1
      [0, 0, 0], // Payline 2
      [2, 2, 2], // Payline 3
      [0, 1, 2], // Payline 4 (Diagonal)
      [2, 1, 0], // Payline 5(Diagonal)
  ];

  const wildSymbol = 0;

  if (!reels || !Array.isArray(reels) || reels.length < 3) {
      return { totalWin: 0, winningLines: [] };
  }

  isScatterWin = reels.every(reel => reel.includes(0));
  console.log("reels", isScatterWin);

  for (let l = 0; l < paylines.length; l++) {
      let lineData = [
          reels[0][paylines[l][0]],
          reels[1][paylines[l][1]],
          reels[2][paylines[l][2]],
      ];

      let mainSymbol = lineData[0];


      if (mainSymbol == null) continue;

      let matchCount = 0;

      for (let s of lineData) {
          if (s == mainSymbol) {
              matchCount++;
          }
      }

      if (matchCount == 3) {
          if (isScatterWin) {
              isFight = true
          }
          let currentWin = payoutTable[mainSymbol] * betAmount;
          let winData = {
              symbol: mainSymbol,
              lineNumber: l + 1,
              line: paylines[l],
              lineData,
              symbolCount: matchCount,
              totalWin: currentWin
          };

          totalWin += currentWin;

          winningLines.push(winData);
      }
  }

  return { totalWin, winningLines, isFight };
};


module.exports = { checkPaylineWin };
mujhe isme esa logic lgana hai 
ki const Player = require("../models/roosterPlayer.js");
const { checkPaylineWin } = require("../helper/roosterWinCalculate.js")


const spin = async (req, res) => {
  const { username, bet, gamble } = req.body;
  const player = await Player.findOne({ username });
  if (!player || player.balance < bet) return res.status(400).send("Insufficient balance");

  let freeSpinActive = false
  const reelStrip = {
      1: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 1, 3, 4, 4, 1, 6, 7, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6],
      2: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 1, 6, 7, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6],
      3: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 3, 3, 3, 3, 4, 4, 1, 6, 7, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6],
  };

  // let reels = [
  //     await generateRandomReels(reelStrip[1]),
  //     await generateRandomReels(reelStrip[2]),
  //     await generateRandomReels(reelStrip[3])
  // ];

  let reels = [
      [0, 3, 5],
      [1, 0, 5],
      [5, 0, 2],
  ]
  const { totalWin, isFight, winningLines } = checkPaylineWin(reels, bet);



  if (isFight) {
      // console.log("fighting the game");

      response = {
          bet: bet,
          isFight,
          win: totalWin,
          reels: await convertReel(reels),
          winData: winningLines,
          // steckyReel: await convertReel(steckyReels),
      };


      return res.json({
          statusCode: 1,
          message: "Success",
          result: response
      });
  } else {

      response = {
          bet: bet,
          isFight,
          win: totalWin,
          reels: await convertReel(reels),
          winData: winningLines,
          // steckyReel: await convertReel(steckyReels),
      };


      return res.json({
          statusCode: 1,
          message: "Success",
          result: response
      });
  }


}

const generateRandomReels = (reelStrip) => {
  let randomInt = Math.floor(Math.random() * (reelStrip.length));
  let resultReel = [];
  resultReel.push(reelStrip[(randomInt + 0) % reelStrip.length]);
  resultReel.push(reelStrip[(randomInt + 1) % reelStrip.length]);
  resultReel.push(reelStrip[(randomInt + 2) % reelStrip.length]);
  return resultReel;
};



const looping = async (req, res) => {
  try {
      let totalWinSum = 0;
      let totalBetAmount = 0;
      let totalFreeSpins = 0;
      let totalWins = 0;
      let results = [];
      const betAmount = Number(req.body.bet) || 0;
      for (let i = 1; i <= 100000; i++) {
          const Req = { body: req.body };
          const Res = {
              json: (data) => {

                  if (data.result.win !== undefined) {
                      totalWinSum += data.result.win;
                      if (data.result.win > 0) {
                          totalWins++;
                      }
                  }
                  if (data.result.freeSpinWin !== undefined) {
                      totalFreeSpins += data.result.freeSpinWin
                  }
                  // if (!data.result.freeSpinActive) {
                  //   totalBetAmount += Number(req.body.betAmount) || 0;
                  // }

                  if (!data.result.freeSpinActive) {
                      totalBetAmount += betAmount;
                  }

                  results.push(data);
              },
              status: () => Res,
          };

          console.log(i, "=>", "RTP", (totalWinSum / totalBetAmount) * 100, "totalWins count => ", totalWins, "total win= ", totalWinSum, "total bet = ", totalBetAmount);
          await spin(Req, Res);
      }

      // totalBetAmount -= totalFreeSpins * Number(req.body.betAmount);
      let RTP = (totalWinSum / totalBetAmount) * 100;

      res.json({
          message: "1000 spins complete",
          totalWin: totalWinSum,
          totalBet: totalBetAmount < 0 ? 0 : totalBetAmount,
          totalRTP: RTP,
          totalFreeSpins: totalFreeSpins,
          // totalWinsCount: totalWins, // Add total winning count
          // sampleResults: results,
      });
  } catch (error) {
      console.log(error);

      res.status(500).json({ message: "Error in looping", error });
  }
};


async function convertReel(reels) {

  let response = [
      { reel: reels[0] },
      { reel: reels[1] },
      { reel: reels[2] },

  ];
  return response;
}
module.exports = { spin, looping };



























const checkPaylineWin = (reels, betAmount) => {
  let totalWin = 0;
  let winningLines = [];
  let isFight = false;
  
  const payoutTable = {
      0: 0.25,  // scatter
      1: 5.0,    // "golden_rooster"
      2: 1.0,    // "purple_rooster"
      3: 0.50,   // "red_rooster"
      4: 0.20,   // "white_rooster"
      5: 0.07,   // "dark_blue_rooster"
      6: 0.05,   // "blue_rooster"
      7: 0.03    // "green_rooster"
  };

  const paylines = [
      [1, 1, 1], // Payline 1
      [0, 0, 0], // Payline 2
      [2, 2, 2], // Payline 3
      [0, 1, 2], // Payline 4 (Diagonal)
      [2, 1, 0], // Payline 5(Diagonal)
  ];

  if (!reels || !Array.isArray(reels) || reels.length < 3) {
      return { totalWin: 0, winningLines: [] };
  }

  let isScatterWin = reels.every(reel => reel.includes(0));

  for (let l = 0; l < paylines.length; l++) {
      let lineData = [
          reels[0][paylines[l][0]],
          reels[1][paylines[l][1]],
          reels[2][paylines[l][2]],
      ];

      let mainSymbol = lineData[0];
      if (mainSymbol == null) continue;

      let matchCount = lineData.filter(s => s === mainSymbol).length;

      if (matchCount === 3) {
          let currentWin = payoutTable[mainSymbol] * betAmount;
          let winData = {
              symbol: mainSymbol,
              lineNumber: l + 1,
              line: paylines[l],
              lineData,
              symbolCount: matchCount,
              totalWin: currentWin
          };
          totalWin += currentWin;
          winningLines.push(winData);
      }
  }

  if (isScatterWin) {
      let scatterIndexes = reels.map(reel => reel.indexOf(0));
      let scatterWinData = {
          symbol: 0,
          lineNumber: 0,
          line: scatterIndexes,
          lineData: [
              reels[0][scatterIndexes[0]],
              reels[1][scatterIndexes[1]],
              reels[2][scatterIndexes[2]],
          ],
          symbolCount: 3,
          totalWin: payoutTable[0] * betAmount * 3
      };
      totalWin += scatterWinData.totalWin;
      winningLines.push(scatterWinData);
      isFight = true;
  }

  return { totalWin, winningLines, isFight };
};

module.exports = { checkPaylineWin };
